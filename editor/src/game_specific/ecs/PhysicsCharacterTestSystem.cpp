#include "PhysicsCharacterTestSystem.h"

namespace Peeler::ECS {
    PhysicsCharacterTestSystem::PhysicsCharacterTestSystem(Carrot::ECS::World& world)
            : Carrot::ECS::LogicSystem<Carrot::ECS::TransformComponent, Carrot::ECS::PhysicsCharacterComponent>(world) {
        movementInput.suggestBinding(Carrot::IO::GLFWGamepadVec2Binding(0, Carrot::IO::GameInputVectorType::LeftStick));
        inputSet.add(movementInput);
        inputSet.activate();
    }

    void PhysicsCharacterTestSystem::tick(double dt) {
        forEachEntity([&](Carrot::ECS::Entity& entity, Carrot::ECS::TransformComponent& transformComp, Carrot::ECS::PhysicsCharacterComponent& characterComp) {
            if(characterComp.character.isOnGround()) {
                glm::vec3 velocity{0.0f};
                float speed = 2.0f;
                velocity.x = movementInput.getValue().x * speed;
                velocity.y = movementInput.getValue().y * speed;
                velocity.z = 0.0f;

                characterComp.character.setVelocity(velocity);
            }

            if(firstFrame) {
                characterComp.character.setWorldTransform(transformComp.computeGlobalPhysicsTransform());
                characterComp.character.update(dt);
                firstFrame = false;
            } else {
                characterComp.character.update(dt);
                transformComp.setGlobalTransform(characterComp.character.getWorldTransform());
            }

        });
    }

    void PhysicsCharacterTestSystem::onFrame(Carrot::Render::Context renderContext) {
        // TODO: autogenerated
    }

    std::unique_ptr <Carrot::ECS::System> PhysicsCharacterTestSystem::duplicate(Carrot::ECS::World& newWorld) const {
        std::unique_ptr<PhysicsCharacterTestSystem> result = std::make_unique<PhysicsCharacterTestSystem>(newWorld);
        return result;
    }

    void PhysicsCharacterTestSystem::reload() {
        firstFrame = true;
        forEachEntity([&](Carrot::ECS::Entity& entity, Carrot::ECS::TransformComponent& transformComp, Carrot::ECS::PhysicsCharacterComponent& characterComp) {
            characterComp.character.addToWorld();
        });
    }

    void PhysicsCharacterTestSystem::unload() {
        forEachEntity([&](Carrot::ECS::Entity& entity, Carrot::ECS::TransformComponent& transformComp, Carrot::ECS::PhysicsCharacterComponent& characterComp) {
            characterComp.character.removeFromWorld();
        });
    }
}