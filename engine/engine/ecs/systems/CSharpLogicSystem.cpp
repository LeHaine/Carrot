#include "CSharpLogicSystem.h"
#include "mono/metadata/object.h"
#include <engine/Engine.h>
#include <core/scripting/csharp/Engine.h>
#include <core/scripting/csharp/CSArray.h>
#include <core/scripting/csharp/CSObject.h>
#include <core/scripting/csharp/CSClass.h>
#include <core/scripting/csharp/CSMethod.h>

namespace Carrot::ECS {
    CSharpLogicSystem::CSharpLogicSystem(Carrot::ECS::World& world, const std::string& namespaceName, const std::string& className) : Carrot::ECS::System(world),
        namespaceName(namespaceName), className(className)
    {
        loadCallbackHandle = GetCSharpBindings().registerGameAssemblyLoadCallback([&]() { onAssemblyLoad(); });
        unloadCallbackHandle = GetCSharpBindings().registerGameAssemblyUnloadCallback([&]() { onAssemblyUnload(); });

        init();
    }

    CSharpLogicSystem::CSharpLogicSystem(const rapidjson::Value& json, Carrot::ECS::World& world): Carrot::ECS::System(world) {
        loadCallbackHandle = GetCSharpBindings().registerGameAssemblyLoadCallback([&]() { onAssemblyLoad(); });
        unloadCallbackHandle = GetCSharpBindings().registerGameAssemblyUnloadCallback([&]() { onAssemblyUnload(); });

        namespaceName = json["cs_namespace"].GetString();
        className = json["cs_class"].GetString();
        init();
    }

    CSharpLogicSystem::~CSharpLogicSystem() {
        GetCSharpBindings().unregisterGameAssemblyLoadCallback(loadCallbackHandle);
        GetCSharpBindings().unregisterGameAssemblyUnloadCallback(unloadCallbackHandle);
    }

    void CSharpLogicSystem::init() {
        systemName = namespaceName;
        systemName += '.';
        systemName += className;
        systemName += " (C#)";

        Scripting::CSClass* clazz = GetCSharpScripting().findClass(namespaceName, className);
        if(!clazz) {
            foundInAssemblies = false;
            return;
        }
        foundInAssemblies = true;
        csTickMethod = clazz->findMethod("Tick", 1);
        std::uint64_t ptr = reinterpret_cast<std::uint64_t>(this);
        void* args[1] { (void*)&ptr };
        csSystem = clazz->newObject(args);

        Scripting::CSClass* signatureClass = GetCSharpScripting().findClass("Carrot", "Signature");
        verify(signatureClass, "Could not find Carrot.Signature class");

        Scripting::CSClass* systemClass = GetCSharpScripting().findClass("Carrot", "System");
        verify(systemClass, "Could not find Carrot.System class");
        Scripting::CSField* signatureField = systemClass->findField("_signature");
        verify(signatureField, "Could not find Carrot.System::_signature field");

        Scripting::CSObject signatureObj = signatureField->get(*csSystem);

        Scripting::CSClass* bitArrayClass = GetCSharpScripting().findClass("System.Collections", "BitArray");
        verify(bitArrayClass, "Could not find System.Collections.BitArray class")

        Scripting::CSField* componentsField = signatureClass->findField("_components");
        verify(componentsField, "Could not find Carrot.Signature::_components field");

        Scripting::CSObject bitArrayObj = componentsField->get(signatureObj);

        Scripting::CSMethod* getMethod = bitArrayClass->findMethod("Get");
        verify(bitArrayClass, "Could not find System.Collections.BitArray::Get method")

        signature.clear();
        for (std::size_t j = 0; j < MAX_COMPONENTS; ++j) {
            void* args[1] = {
                    &j
            };
            bool hasComponent = *((bool*)mono_object_unbox(getMethod->invoke(bitArrayObj, args)));
            if(hasComponent) {
                signature.addComponent(j);
            }
        }

        world.reloadSystemEntities(this);
        recreateEntityList();
    }

    void CSharpLogicSystem::tick(double dt) {
        if(!foundInAssemblies) {
            return;
        }
        if(*csSystem) {
            void* args[1] { (void*)&dt };
            csTickMethod->invoke(*csSystem, args);
        }
    }

    void CSharpLogicSystem::onFrame(Carrot::Render::Context renderContext) {
        // TODO: autogenerated
    }

    void CSharpLogicSystem::onEntitiesAdded(const std::vector<EntityID>& entities) {
        System::onEntitiesAdded(entities);
        recreateEntityList();
    }

    void CSharpLogicSystem::onEntitiesRemoved(const std::vector<EntityID>& entities) {
        System::onEntitiesRemoved(entities);
        recreateEntityList();
    }

    void CSharpLogicSystem::onEntitiesUpdated(const std::vector<EntityID>& entities) {
        System::onEntitiesUpdated(entities);
        recreateEntityList();
    }

    void CSharpLogicSystem::recreateEntityList() {
        auto* entityClass = GetCSharpScripting().findClass("Carrot", "Entity");
        verify(entityClass, "No Carrot.Entity class?");

        csEntities = entityClass->newArray(entities.size());

        std::size_t i = 0;
        for(auto& e : entities) {
            EntityID uuid = e.getID();
            World* worldPtr = &world;
            void* args[2] = {
                    &uuid,
                    &worldPtr,
            };
            auto entityObj = entityClass->newObject(args);
            csEntities->set(i, *entityObj);
            i++;
        }
    }

    std::unique_ptr <Carrot::ECS::System> CSharpLogicSystem::duplicate(Carrot::ECS::World& newWorld) const {
        std::unique_ptr<CSharpLogicSystem> result = std::make_unique<CSharpLogicSystem>(newWorld, namespaceName, className);
        return result;
    }

    const char *CSharpLogicSystem::getName() const {
        return systemName.c_str();
    }

    rapidjson::Value CSharpLogicSystem::toJSON(rapidjson::Document::AllocatorType& allocator) const {
        // TODO
        return System::toJSON(allocator);
    }

    Scripting::CSArray* CSharpLogicSystem::getEntityList() {
        return csEntities.get();
    }

    void CSharpLogicSystem::onAssemblyLoad() {
        init();
    }

    void CSharpLogicSystem::onAssemblyUnload() {
        csSystem = nullptr;
        csTickMethod = nullptr;
        csEntities = nullptr;
    }
}